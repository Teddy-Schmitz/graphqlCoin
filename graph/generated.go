// This file was generated by github.com/vektah/gqlgen, DO NOT EDIT

package graph

import (
	"bytes"
	context "context"
	strconv "strconv"

	rpcclient "github.com/Teddy-Schmitz/graphqlCoin/rpcclient"
	graphql "github.com/vektah/gqlgen/graphql"
	errors "github.com/vektah/gqlgen/neelance/errors"
	introspection "github.com/vektah/gqlgen/neelance/introspection"
	query "github.com/vektah/gqlgen/neelance/query"
	schema "github.com/vektah/gqlgen/neelance/schema"
)

func MakeExecutableSchema(resolvers Resolvers) graphql.ExecutableSchema {
	return &executableSchema{resolvers}
}

type Resolvers interface {
	Block_transactions(ctx context.Context, obj *rpcclient.Block) ([]rpcclient.Transaction, error)

	Query_block(ctx context.Context, hash *string, height *uint64) (rpcclient.Block, error)
	Query_transaction(ctx context.Context, id string) (rpcclient.Transaction, error)
	Query_estimatefee(ctx context.Context, blocks int) (rpcclient.FeeEstimate, error)
	Query_difficulty(ctx context.Context) (float64, error)
	Query_mempool(ctx context.Context) ([]rpcclient.MemPoolTrx, error)

	Transaction_block(ctx context.Context, obj *rpcclient.Transaction) (rpcclient.Block, error)
}

type executableSchema struct {
	resolvers Resolvers
}

func (e *executableSchema) Schema() *schema.Schema {
	return parsedSchema
}

func (e *executableSchema) Query(ctx context.Context, doc *query.Document, variables map[string]interface{}, op *query.Operation, recover graphql.RecoverFunc) *graphql.Response {
	ec := executionContext{resolvers: e.resolvers, variables: variables, doc: doc, ctx: ctx, recover: recover}

	data := ec._Query(op.Selections)
	var buf bytes.Buffer
	data.MarshalGQL(&buf)

	return &graphql.Response{
		Data:   buf.Bytes(),
		Errors: ec.Errors,
	}
}

func (e *executableSchema) Mutation(ctx context.Context, doc *query.Document, variables map[string]interface{}, op *query.Operation, recover graphql.RecoverFunc) *graphql.Response {
	return &graphql.Response{Errors: []*errors.QueryError{{Message: "mutations are not supported"}}}
}

func (e *executableSchema) Subscription(ctx context.Context, doc *query.Document, variables map[string]interface{}, op *query.Operation, recover graphql.RecoverFunc) func() *graphql.Response {
	return graphql.OneShot(&graphql.Response{Errors: []*errors.QueryError{{Message: "subscriptions are not supported"}}})
}

type executionContext struct {
	errors.Builder
	resolvers Resolvers
	variables map[string]interface{}
	doc       *query.Document
	ctx       context.Context
	recover   graphql.RecoverFunc
}

var blockImplementors = []string{"Block"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Block(sel []query.Selection, obj *rpcclient.Block) graphql.Marshaler {
	fields := graphql.CollectFields(ec.doc, sel, blockImplementors, ec.variables)
	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Block")
		case "hash":
			out.Values[i] = ec._Block_hash(field, obj)
		case "strippedsize":
			out.Values[i] = ec._Block_strippedsize(field, obj)
		case "size":
			out.Values[i] = ec._Block_size(field, obj)
		case "height":
			out.Values[i] = ec._Block_height(field, obj)
		case "confirmations":
			out.Values[i] = ec._Block_confirmations(field, obj)
		case "weight":
			out.Values[i] = ec._Block_weight(field, obj)
		case "time":
			out.Values[i] = ec._Block_time(field, obj)
		case "bits":
			out.Values[i] = ec._Block_bits(field, obj)
		case "version":
			out.Values[i] = ec._Block_version(field, obj)
		case "versionhex":
			out.Values[i] = ec._Block_versionhex(field, obj)
		case "merkleroot":
			out.Values[i] = ec._Block_merkleroot(field, obj)
		case "mediantime":
			out.Values[i] = ec._Block_mediantime(field, obj)
		case "nonce":
			out.Values[i] = ec._Block_nonce(field, obj)
		case "difficulty":
			out.Values[i] = ec._Block_difficulty(field, obj)
		case "chainwork":
			out.Values[i] = ec._Block_chainwork(field, obj)
		case "previousblockhash":
			out.Values[i] = ec._Block_previousblockhash(field, obj)
		case "nextblockhash":
			out.Values[i] = ec._Block_nextblockhash(field, obj)
		case "trxIDs":
			out.Values[i] = ec._Block_trxIDs(field, obj)
		case "transactions":
			out.Values[i] = ec._Block_transactions(field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _Block_hash(field graphql.CollectedField, obj *rpcclient.Block) graphql.Marshaler {
	res := obj.Hash
	return graphql.MarshalString(res)
}

func (ec *executionContext) _Block_strippedsize(field graphql.CollectedField, obj *rpcclient.Block) graphql.Marshaler {
	res := obj.StrippedSize
	return MarshalUInt64(res)
}

func (ec *executionContext) _Block_size(field graphql.CollectedField, obj *rpcclient.Block) graphql.Marshaler {
	res := obj.Size
	return MarshalUInt64(res)
}

func (ec *executionContext) _Block_height(field graphql.CollectedField, obj *rpcclient.Block) graphql.Marshaler {
	res := obj.Height
	return MarshalUInt64(res)
}

func (ec *executionContext) _Block_confirmations(field graphql.CollectedField, obj *rpcclient.Block) graphql.Marshaler {
	res := obj.Confirmations
	return MarshalUInt64(res)
}

func (ec *executionContext) _Block_weight(field graphql.CollectedField, obj *rpcclient.Block) graphql.Marshaler {
	res := obj.Weight
	return MarshalUInt64(res)
}

func (ec *executionContext) _Block_time(field graphql.CollectedField, obj *rpcclient.Block) graphql.Marshaler {
	res := obj.Time()
	return graphql.MarshalTime(res)
}

func (ec *executionContext) _Block_bits(field graphql.CollectedField, obj *rpcclient.Block) graphql.Marshaler {
	res := obj.Bits
	return graphql.MarshalString(res)
}

func (ec *executionContext) _Block_version(field graphql.CollectedField, obj *rpcclient.Block) graphql.Marshaler {
	res := obj.Version
	return MarshalUInt64(res)
}

func (ec *executionContext) _Block_versionhex(field graphql.CollectedField, obj *rpcclient.Block) graphql.Marshaler {
	res := obj.VersionHex
	return graphql.MarshalString(res)
}

func (ec *executionContext) _Block_merkleroot(field graphql.CollectedField, obj *rpcclient.Block) graphql.Marshaler {
	res := obj.MerkleRoot
	return graphql.MarshalString(res)
}

func (ec *executionContext) _Block_mediantime(field graphql.CollectedField, obj *rpcclient.Block) graphql.Marshaler {
	res := obj.MedianTime()
	return graphql.MarshalTime(res)
}

func (ec *executionContext) _Block_nonce(field graphql.CollectedField, obj *rpcclient.Block) graphql.Marshaler {
	res := obj.Nonce
	return MarshalInt64(res)
}

func (ec *executionContext) _Block_difficulty(field graphql.CollectedField, obj *rpcclient.Block) graphql.Marshaler {
	res := obj.Difficulty
	return graphql.MarshalFloat(res)
}

func (ec *executionContext) _Block_chainwork(field graphql.CollectedField, obj *rpcclient.Block) graphql.Marshaler {
	res := obj.Chainwork
	return graphql.MarshalString(res)
}

func (ec *executionContext) _Block_previousblockhash(field graphql.CollectedField, obj *rpcclient.Block) graphql.Marshaler {
	res := obj.PreviousBlockhash
	return graphql.MarshalString(res)
}

func (ec *executionContext) _Block_nextblockhash(field graphql.CollectedField, obj *rpcclient.Block) graphql.Marshaler {
	res := obj.NextBlockhash
	return graphql.MarshalString(res)
}

func (ec *executionContext) _Block_trxIDs(field graphql.CollectedField, obj *rpcclient.Block) graphql.Marshaler {
	res := obj.TrxIDs
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler { return graphql.MarshalString(res[idx1]) }())
	}
	return arr1
}

func (ec *executionContext) _Block_transactions(field graphql.CollectedField, obj *rpcclient.Block) graphql.Marshaler {
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.recover(r)
				ec.Error(userErr)
				ret = graphql.Null
			}
		}()
		res, err := ec.resolvers.Block_transactions(ec.ctx, obj)
		if err != nil {
			ec.Error(err)
			return graphql.Null
		}
		arr1 := graphql.Array{}
		for idx1 := range res {
			arr1 = append(arr1, func() graphql.Marshaler { return ec._Transaction(field.Selections, &res[idx1]) }())
		}
		return arr1
	})
}

var feeEstimateImplementors = []string{"FeeEstimate"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _FeeEstimate(sel []query.Selection, obj *rpcclient.FeeEstimate) graphql.Marshaler {
	fields := graphql.CollectFields(ec.doc, sel, feeEstimateImplementors, ec.variables)
	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FeeEstimate")
		case "feerate":
			out.Values[i] = ec._FeeEstimate_feerate(field, obj)
		case "blocks":
			out.Values[i] = ec._FeeEstimate_blocks(field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _FeeEstimate_feerate(field graphql.CollectedField, obj *rpcclient.FeeEstimate) graphql.Marshaler {
	res := obj.FeeRate
	return graphql.MarshalFloat(res)
}

func (ec *executionContext) _FeeEstimate_blocks(field graphql.CollectedField, obj *rpcclient.FeeEstimate) graphql.Marshaler {
	res := obj.Blocks
	return graphql.MarshalInt(res)
}

var memPoolTrxImplementors = []string{"MemPoolTrx"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _MemPoolTrx(sel []query.Selection, obj *rpcclient.MemPoolTrx) graphql.Marshaler {
	fields := graphql.CollectFields(ec.doc, sel, memPoolTrxImplementors, ec.variables)
	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MemPoolTrx")
		case "id":
			out.Values[i] = ec._MemPoolTrx_id(field, obj)
		case "size":
			out.Values[i] = ec._MemPoolTrx_size(field, obj)
		case "fee":
			out.Values[i] = ec._MemPoolTrx_fee(field, obj)
		case "modifiedFee":
			out.Values[i] = ec._MemPoolTrx_modifiedFee(field, obj)
		case "time":
			out.Values[i] = ec._MemPoolTrx_time(field, obj)
		case "height":
			out.Values[i] = ec._MemPoolTrx_height(field, obj)
		case "descendantCount":
			out.Values[i] = ec._MemPoolTrx_descendantCount(field, obj)
		case "descendantSize":
			out.Values[i] = ec._MemPoolTrx_descendantSize(field, obj)
		case "descendantFees":
			out.Values[i] = ec._MemPoolTrx_descendantFees(field, obj)
		case "ancestorCount":
			out.Values[i] = ec._MemPoolTrx_ancestorCount(field, obj)
		case "ancestorSize":
			out.Values[i] = ec._MemPoolTrx_ancestorSize(field, obj)
		case "ancestorFees":
			out.Values[i] = ec._MemPoolTrx_ancestorFees(field, obj)
		case "depends":
			out.Values[i] = ec._MemPoolTrx_depends(field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _MemPoolTrx_id(field graphql.CollectedField, obj *rpcclient.MemPoolTrx) graphql.Marshaler {
	res := obj.ID
	return graphql.MarshalString(res)
}

func (ec *executionContext) _MemPoolTrx_size(field graphql.CollectedField, obj *rpcclient.MemPoolTrx) graphql.Marshaler {
	res := obj.Size
	return MarshalUInt64(res)
}

func (ec *executionContext) _MemPoolTrx_fee(field graphql.CollectedField, obj *rpcclient.MemPoolTrx) graphql.Marshaler {
	res := obj.Fee
	return graphql.MarshalFloat(res)
}

func (ec *executionContext) _MemPoolTrx_modifiedFee(field graphql.CollectedField, obj *rpcclient.MemPoolTrx) graphql.Marshaler {
	res := obj.ModifiedFee
	return graphql.MarshalFloat(res)
}

func (ec *executionContext) _MemPoolTrx_time(field graphql.CollectedField, obj *rpcclient.MemPoolTrx) graphql.Marshaler {
	res := obj.Time()
	return graphql.MarshalTime(res)
}

func (ec *executionContext) _MemPoolTrx_height(field graphql.CollectedField, obj *rpcclient.MemPoolTrx) graphql.Marshaler {
	res := obj.Height
	return MarshalUInt64(res)
}

func (ec *executionContext) _MemPoolTrx_descendantCount(field graphql.CollectedField, obj *rpcclient.MemPoolTrx) graphql.Marshaler {
	res := obj.DescendantCount
	return MarshalUInt64(res)
}

func (ec *executionContext) _MemPoolTrx_descendantSize(field graphql.CollectedField, obj *rpcclient.MemPoolTrx) graphql.Marshaler {
	res := obj.DescendantSize
	return MarshalUInt64(res)
}

func (ec *executionContext) _MemPoolTrx_descendantFees(field graphql.CollectedField, obj *rpcclient.MemPoolTrx) graphql.Marshaler {
	res := obj.DescendantFees
	return MarshalUInt64(res)
}

func (ec *executionContext) _MemPoolTrx_ancestorCount(field graphql.CollectedField, obj *rpcclient.MemPoolTrx) graphql.Marshaler {
	res := obj.AncestorCount
	return MarshalUInt64(res)
}

func (ec *executionContext) _MemPoolTrx_ancestorSize(field graphql.CollectedField, obj *rpcclient.MemPoolTrx) graphql.Marshaler {
	res := obj.AncestorSize
	return MarshalUInt64(res)
}

func (ec *executionContext) _MemPoolTrx_ancestorFees(field graphql.CollectedField, obj *rpcclient.MemPoolTrx) graphql.Marshaler {
	res := obj.AncestorFees
	return MarshalUInt64(res)
}

func (ec *executionContext) _MemPoolTrx_depends(field graphql.CollectedField, obj *rpcclient.MemPoolTrx) graphql.Marshaler {
	res := obj.Depends
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler { return graphql.MarshalString(res[idx1]) }())
	}
	return arr1
}

var queryImplementors = []string{"Query"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Query(sel []query.Selection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.doc, sel, queryImplementors, ec.variables)
	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "block":
			out.Values[i] = ec._Query_block(field)
		case "transaction":
			out.Values[i] = ec._Query_transaction(field)
		case "estimatefee":
			out.Values[i] = ec._Query_estimatefee(field)
		case "difficulty":
			out.Values[i] = ec._Query_difficulty(field)
		case "mempool":
			out.Values[i] = ec._Query_mempool(field)
		case "__schema":
			out.Values[i] = ec._Query___schema(field)
		case "__type":
			out.Values[i] = ec._Query___type(field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _Query_block(field graphql.CollectedField) graphql.Marshaler {
	var arg0 *string
	if tmp, ok := field.Args["hash"]; ok {
		var err error
		var ptr1 string

		ptr1, err = graphql.UnmarshalString(tmp)
		arg0 = &ptr1
		if err != nil {
			ec.Error(err)
			return graphql.Null
		}
	}
	var arg1 *uint64
	if tmp, ok := field.Args["height"]; ok {
		var err error
		var ptr1 uint64

		ptr1, err = UnmarshalUInt64(tmp)
		arg1 = &ptr1
		if err != nil {
			ec.Error(err)
			return graphql.Null
		}
	}
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.recover(r)
				ec.Error(userErr)
				ret = graphql.Null
			}
		}()
		res, err := ec.resolvers.Query_block(ec.ctx, arg0, arg1)
		if err != nil {
			ec.Error(err)
			return graphql.Null
		}
		return ec._Block(field.Selections, &res)
	})
}

func (ec *executionContext) _Query_transaction(field graphql.CollectedField) graphql.Marshaler {
	var arg0 string
	if tmp, ok := field.Args["id"]; ok {
		var err error

		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(err)
			return graphql.Null
		}
	}
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.recover(r)
				ec.Error(userErr)
				ret = graphql.Null
			}
		}()
		res, err := ec.resolvers.Query_transaction(ec.ctx, arg0)
		if err != nil {
			ec.Error(err)
			return graphql.Null
		}
		return ec._Transaction(field.Selections, &res)
	})
}

func (ec *executionContext) _Query_estimatefee(field graphql.CollectedField) graphql.Marshaler {
	var arg0 int
	if tmp, ok := field.Args["blocks"]; ok {
		var err error

		arg0, err = graphql.UnmarshalInt(tmp)
		if err != nil {
			ec.Error(err)
			return graphql.Null
		}
	} else {
		var tmp interface{} = 2
		var err error

		arg0, err = graphql.UnmarshalInt(tmp)
		if err != nil {
			ec.Error(err)
			return graphql.Null
		}
	}

	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.recover(r)
				ec.Error(userErr)
				ret = graphql.Null
			}
		}()
		res, err := ec.resolvers.Query_estimatefee(ec.ctx, arg0)
		if err != nil {
			ec.Error(err)
			return graphql.Null
		}
		return ec._FeeEstimate(field.Selections, &res)
	})
}

func (ec *executionContext) _Query_difficulty(field graphql.CollectedField) graphql.Marshaler {
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.recover(r)
				ec.Error(userErr)
				ret = graphql.Null
			}
		}()
		res, err := ec.resolvers.Query_difficulty(ec.ctx)
		if err != nil {
			ec.Error(err)
			return graphql.Null
		}
		return graphql.MarshalFloat(res)
	})
}

func (ec *executionContext) _Query_mempool(field graphql.CollectedField) graphql.Marshaler {
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.recover(r)
				ec.Error(userErr)
				ret = graphql.Null
			}
		}()
		res, err := ec.resolvers.Query_mempool(ec.ctx)
		if err != nil {
			ec.Error(err)
			return graphql.Null
		}
		arr1 := graphql.Array{}
		for idx1 := range res {
			arr1 = append(arr1, func() graphql.Marshaler { return ec._MemPoolTrx(field.Selections, &res[idx1]) }())
		}
		return arr1
	})
}

func (ec *executionContext) _Query___schema(field graphql.CollectedField) graphql.Marshaler {
	res := ec.introspectSchema()
	if res == nil {
		return graphql.Null
	}
	return ec.___Schema(field.Selections, res)
}

func (ec *executionContext) _Query___type(field graphql.CollectedField) graphql.Marshaler {
	var arg0 string
	if tmp, ok := field.Args["name"]; ok {
		var err error

		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(err)
			return graphql.Null
		}
	}
	res := ec.introspectType(arg0)
	if res == nil {
		return graphql.Null
	}
	return ec.___Type(field.Selections, res)
}

var transactionImplementors = []string{"Transaction"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Transaction(sel []query.Selection, obj *rpcclient.Transaction) graphql.Marshaler {
	fields := graphql.CollectFields(ec.doc, sel, transactionImplementors, ec.variables)
	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Transaction")
		case "id":
			out.Values[i] = ec._Transaction_id(field, obj)
		case "hash":
			out.Values[i] = ec._Transaction_hash(field, obj)
		case "version":
			out.Values[i] = ec._Transaction_version(field, obj)
		case "size":
			out.Values[i] = ec._Transaction_size(field, obj)
		case "vsize":
			out.Values[i] = ec._Transaction_vsize(field, obj)
		case "locktime":
			out.Values[i] = ec._Transaction_locktime(field, obj)
		case "blockhash":
			out.Values[i] = ec._Transaction_blockhash(field, obj)
		case "time":
			out.Values[i] = ec._Transaction_time(field, obj)
		case "confirmations":
			out.Values[i] = ec._Transaction_confirmations(field, obj)
		case "blocktime":
			out.Values[i] = ec._Transaction_blocktime(field, obj)
		case "block":
			out.Values[i] = ec._Transaction_block(field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _Transaction_id(field graphql.CollectedField, obj *rpcclient.Transaction) graphql.Marshaler {
	res := obj.ID
	return graphql.MarshalString(res)
}

func (ec *executionContext) _Transaction_hash(field graphql.CollectedField, obj *rpcclient.Transaction) graphql.Marshaler {
	res := obj.Hash
	return graphql.MarshalString(res)
}

func (ec *executionContext) _Transaction_version(field graphql.CollectedField, obj *rpcclient.Transaction) graphql.Marshaler {
	res := obj.Version
	return MarshalUInt64(res)
}

func (ec *executionContext) _Transaction_size(field graphql.CollectedField, obj *rpcclient.Transaction) graphql.Marshaler {
	res := obj.Size
	return MarshalUInt64(res)
}

func (ec *executionContext) _Transaction_vsize(field graphql.CollectedField, obj *rpcclient.Transaction) graphql.Marshaler {
	res := obj.Vsize
	return MarshalUInt64(res)
}

func (ec *executionContext) _Transaction_locktime(field graphql.CollectedField, obj *rpcclient.Transaction) graphql.Marshaler {
	res := obj.Locktime
	return MarshalUInt64(res)
}

func (ec *executionContext) _Transaction_blockhash(field graphql.CollectedField, obj *rpcclient.Transaction) graphql.Marshaler {
	res := obj.BlockHash
	return graphql.MarshalString(res)
}

func (ec *executionContext) _Transaction_time(field graphql.CollectedField, obj *rpcclient.Transaction) graphql.Marshaler {
	res := obj.Time()
	return graphql.MarshalTime(res)
}

func (ec *executionContext) _Transaction_confirmations(field graphql.CollectedField, obj *rpcclient.Transaction) graphql.Marshaler {
	res := obj.Confirmations
	return MarshalUInt64(res)
}

func (ec *executionContext) _Transaction_blocktime(field graphql.CollectedField, obj *rpcclient.Transaction) graphql.Marshaler {
	res := obj.BlockTime()
	return graphql.MarshalTime(res)
}

func (ec *executionContext) _Transaction_block(field graphql.CollectedField, obj *rpcclient.Transaction) graphql.Marshaler {
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.recover(r)
				ec.Error(userErr)
				ret = graphql.Null
			}
		}()
		res, err := ec.resolvers.Transaction_block(ec.ctx, obj)
		if err != nil {
			ec.Error(err)
			return graphql.Null
		}
		return ec._Block(field.Selections, &res)
	})
}

var __DirectiveImplementors = []string{"__Directive"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Directive(sel []query.Selection, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.doc, sel, __DirectiveImplementors, ec.variables)
	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(field, obj)
		case "description":
			out.Values[i] = ec.___Directive_description(field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(field, obj)
		case "args":
			out.Values[i] = ec.___Directive_args(field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) ___Directive_name(field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	res := obj.Name()
	return graphql.MarshalString(res)
}

func (ec *executionContext) ___Directive_description(field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	res := obj.Description()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

func (ec *executionContext) ___Directive_locations(field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	res := obj.Locations()
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler { return graphql.MarshalString(res[idx1]) }())
	}
	return arr1
}

func (ec *executionContext) ___Directive_args(field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	res := obj.Args()
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			if res[idx1] == nil {
				return graphql.Null
			}
			return ec.___InputValue(field.Selections, res[idx1])
		}())
	}
	return arr1
}

var __EnumValueImplementors = []string{"__EnumValue"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___EnumValue(sel []query.Selection, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.doc, sel, __EnumValueImplementors, ec.variables)
	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(field, obj)
		case "description":
			out.Values[i] = ec.___EnumValue_description(field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(field, obj)
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) ___EnumValue_name(field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	res := obj.Name()
	return graphql.MarshalString(res)
}

func (ec *executionContext) ___EnumValue_description(field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	res := obj.Description()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

func (ec *executionContext) ___EnumValue_isDeprecated(field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	res := obj.IsDeprecated()
	return graphql.MarshalBoolean(res)
}

func (ec *executionContext) ___EnumValue_deprecationReason(field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	res := obj.DeprecationReason()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var __FieldImplementors = []string{"__Field"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Field(sel []query.Selection, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.doc, sel, __FieldImplementors, ec.variables)
	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(field, obj)
		case "description":
			out.Values[i] = ec.___Field_description(field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(field, obj)
		case "type":
			out.Values[i] = ec.___Field_type(field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(field, obj)
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) ___Field_name(field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	res := obj.Name()
	return graphql.MarshalString(res)
}

func (ec *executionContext) ___Field_description(field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	res := obj.Description()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

func (ec *executionContext) ___Field_args(field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	res := obj.Args()
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			if res[idx1] == nil {
				return graphql.Null
			}
			return ec.___InputValue(field.Selections, res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Field_type(field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	res := obj.Type()
	if res == nil {
		return graphql.Null
	}
	return ec.___Type(field.Selections, res)
}

func (ec *executionContext) ___Field_isDeprecated(field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	res := obj.IsDeprecated()
	return graphql.MarshalBoolean(res)
}

func (ec *executionContext) ___Field_deprecationReason(field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	res := obj.DeprecationReason()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var __InputValueImplementors = []string{"__InputValue"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___InputValue(sel []query.Selection, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.doc, sel, __InputValueImplementors, ec.variables)
	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(field, obj)
		case "description":
			out.Values[i] = ec.___InputValue_description(field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(field, obj)
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) ___InputValue_name(field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	res := obj.Name()
	return graphql.MarshalString(res)
}

func (ec *executionContext) ___InputValue_description(field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	res := obj.Description()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

func (ec *executionContext) ___InputValue_type(field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	res := obj.Type()
	if res == nil {
		return graphql.Null
	}
	return ec.___Type(field.Selections, res)
}

func (ec *executionContext) ___InputValue_defaultValue(field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	res := obj.DefaultValue()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var __SchemaImplementors = []string{"__Schema"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Schema(sel []query.Selection, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.doc, sel, __SchemaImplementors, ec.variables)
	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "types":
			out.Values[i] = ec.___Schema_types(field, obj)
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(field, obj)
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) ___Schema_types(field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	res := obj.Types()
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			if res[idx1] == nil {
				return graphql.Null
			}
			return ec.___Type(field.Selections, res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Schema_queryType(field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	res := obj.QueryType()
	if res == nil {
		return graphql.Null
	}
	return ec.___Type(field.Selections, res)
}

func (ec *executionContext) ___Schema_mutationType(field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	res := obj.MutationType()
	if res == nil {
		return graphql.Null
	}
	return ec.___Type(field.Selections, res)
}

func (ec *executionContext) ___Schema_subscriptionType(field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	res := obj.SubscriptionType()
	if res == nil {
		return graphql.Null
	}
	return ec.___Type(field.Selections, res)
}

func (ec *executionContext) ___Schema_directives(field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	res := obj.Directives()
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			if res[idx1] == nil {
				return graphql.Null
			}
			return ec.___Directive(field.Selections, res[idx1])
		}())
	}
	return arr1
}

var __TypeImplementors = []string{"__Type"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Type(sel []query.Selection, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.doc, sel, __TypeImplementors, ec.variables)
	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(field, obj)
		case "name":
			out.Values[i] = ec.___Type_name(field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) ___Type_kind(field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	res := obj.Kind()
	return graphql.MarshalString(res)
}

func (ec *executionContext) ___Type_name(field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	res := obj.Name()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

func (ec *executionContext) ___Type_description(field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	res := obj.Description()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

func (ec *executionContext) ___Type_fields(field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	var arg0 bool
	if tmp, ok := field.Args["includeDeprecated"]; ok {
		var err error

		arg0, err = graphql.UnmarshalBoolean(tmp)
		if err != nil {
			ec.Error(err)
			return graphql.Null
		}
	}
	res := obj.Fields(arg0)
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			if res[idx1] == nil {
				return graphql.Null
			}
			return ec.___Field(field.Selections, res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Type_interfaces(field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	res := obj.Interfaces()
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			if res[idx1] == nil {
				return graphql.Null
			}
			return ec.___Type(field.Selections, res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Type_possibleTypes(field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	res := obj.PossibleTypes()
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			if res[idx1] == nil {
				return graphql.Null
			}
			return ec.___Type(field.Selections, res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Type_enumValues(field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	var arg0 bool
	if tmp, ok := field.Args["includeDeprecated"]; ok {
		var err error

		arg0, err = graphql.UnmarshalBoolean(tmp)
		if err != nil {
			ec.Error(err)
			return graphql.Null
		}
	}
	res := obj.EnumValues(arg0)
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			if res[idx1] == nil {
				return graphql.Null
			}
			return ec.___EnumValue(field.Selections, res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Type_inputFields(field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	res := obj.InputFields()
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			if res[idx1] == nil {
				return graphql.Null
			}
			return ec.___InputValue(field.Selections, res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Type_ofType(field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	res := obj.OfType()
	if res == nil {
		return graphql.Null
	}
	return ec.___Type(field.Selections, res)
}

var parsedSchema = schema.MustParse("schema {\n    query: Query\n}\n\ntype Query {\n    block(hash: String, height: UInt64): Block!\n    transaction(id: String!): Transaction!\n    estimatefee(blocks: Int = 2): FeeEstimate!\n    difficulty: Float!\n    mempool: [MemPoolTrx]\n}\n\nscalar Time\nscalar UInt64\nscalar Int64\n\ntype Block {\n    hash: String!\n    strippedsize: UInt64!\n    size: UInt64!\n    height: UInt64!\n    confirmations: UInt64!\n    weight: UInt64!\n    time: Time!\n    bits: String!\n    version: UInt64!\n    versionhex: String!\n    merkleroot: String!\n    mediantime: Time!\n    nonce: Int64!\n    difficulty: Float!\n    chainwork: String!\n    previousblockhash: String!\n    nextblockhash: String!\n    trxIDs: [String]\n\n    transactions: [Transaction]\n}\n\ntype Transaction {\n    id: String!\n    hash: String!\n    version: UInt64!\n    size: UInt64!\n    vsize: UInt64!\n    locktime: UInt64!\n    blockhash: String!\n    time: Time!\n    confirmations: UInt64!\n    blocktime: Time!\n\n    block: Block!\n}\n\ntype FeeEstimate {\n    feerate: Float!\n    blocks: Int!\n}\n\ntype MemPoolTrx {\n    id: String!\n    size: UInt64!\n    fee: Float!\n    modifiedFee: Float!\n    time: Time!\n    height: UInt64!\n    descendantCount: UInt64!\n    descendantSize: UInt64!\n    descendantFees: UInt64!\n    ancestorCount: UInt64!\n    ancestorSize: UInt64!\n    ancestorFees: UInt64!\n    depends: [String]\n}")

func (ec *executionContext) introspectSchema() *introspection.Schema {
	return introspection.WrapSchema(parsedSchema)
}

func (ec *executionContext) introspectType(name string) *introspection.Type {
	t := parsedSchema.Resolve(name)
	if t == nil {
		return nil
	}
	return introspection.WrapType(t)
}
